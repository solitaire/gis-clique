\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\title{\textbf{Poszukiwanie największej kliki w~grafie}}
\author{Anna Stępień \\ Adam Stelmaszczyk}
\date{}
\setlength{\parindent}{0in}
\renewcommand\refname{Referencje}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{Zadanie}

Kliką grafu nazywamy podgraf, w którym każde dwa wierzchołki są ze sobą połączone.
Maksymalną kliką nazywamy klikę, do której nie można dodać ani jednego wierzchołka więcej, tak aby razem z nią nadal tworzył klikę.
Największą kliką nazywamy klikę o~największej liczbie wierzchołków.
Celem zadania jest implementacja wybranego algorytmu znajdującego największa klikę w~grafie oraz analiza otrzymanych wyników.

\section{Założenia}

Wejściem dla algorytmu jest graf nieskierowany dany macierzą o~$n$~wierszach i~$n$~kolumnach:

\bigskip
$ 
\begin{array}{cccc}
q_{0,0} & q_{1,0} & \ldots & q_{n-1,0} \\
q_{0,1} & q_{1,1} & \ldots & q_{n-1,1} \\
\vdots  & \vdots  & \ddots & \vdots  \\
q_{0,n-1} & q_{1,n-1} & \ldots & q_{n-1,n-1} 
\end{array}
, q_{i,j} \in \{0,1\}, 0 \leq i,j < n
$
\bigskip

$q_{i,j}$ równe 0 oznacza, że wierzchołki i oraz j nie są połączone krawędzią. W~przeciwnym razie, wierzchołki są połączone.
\par\vspace{\baselineskip}
Macierz jest dana w pliku tekstowym, w którym kolejne $q_{i,j}$ w wierszu $j$ są oddzielone co najmniej jednym znakiem białym. 
Przez znak biały rozumiemy spację lub tabulator. $q_{i,j}$ różne od 0 będą traktowane jak 1.
\par\vspace{\baselineskip}
Wyjściem jest niepusty zbiór numerów wierzchołków, które tworzą największą klikę w~podanym grafie. 
Wierzchołki numerujemy od 0 do $n-1$. W~grafie może istnieć więcej niż jedna największa klika.
W~takim przypadku algorytm zwróci dowolną z~nich.

Realizowana aplikacja będzie pracowała w~trybie konsolowym, z~ewentualną możliwością specyfikacji dodatkowych parametrów.
W~projekcie zostanie wykorzystany algorytm Brona--Kerboscha \cite{bk}.

\section{Algorytm}
Algorytm Brona--Kerboscha jest rekurencyjnym algorytmem z nawrotami, który umożliwia poszukiwanie maksymalnych klik w zadanym grafie niezorientowanym.

Domyślnie algorytm zwraca wszystkie maksymalne kliki. W algorytmie wprowadzona zostanie zmiana, dzięki której zwracana będzie największa ze znalezionych maksymalnych klik, charakteryzująca się największą liczbą wierzchołków.


\subsection{Pseudokod}
\begin{algorithm}[!htb]
\caption{Algorytm Brona--Kerboscha (wersja podstawowa)}\label{bron1}
\begin{algorithmic}[1]
\State $compsub \gets \emptyset$
\State $candidates \gets V(G)$
\State $not \gets \emptyset$
\State $cliques \gets \emptyset$
\Function{bron\_kerbosch}{$compsub,candidates,not$}
	\If{$candidates = \emptyset$ \textbf{and} $not = \emptyset$}
		 \State $cliques \gets cliques \cup \{compsub\}$\Comment Maksymalna klika
	\Else
	\For{\textbf{each} $v$ in $candidates$}
		\State $candidates \gets candidates \setminus \{v\}$
		\State $new\_compsub \gets compsub \cup \{v\}$
		\State $new\_candidates \gets candidates \cap neighbors(v)$
		\State $new\_not \gets not \cap neighbors(v)$
		\State\Call{bron\_kerbosch}{$new\_compsub, new\_candidates, new\_not$}
		\State $compsub \gets compsub \cup \{v\}$
	\EndFor
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htb]
\caption{Algorytm Brona--Kerboscha (wersja rozszerzona)}\label{bron2}
\begin{algorithmic}[1]
\State $compsub \gets \emptyset$
\State $candidates \gets V(G)$
\State $not \gets \emptyset$
\State $biggest\_clique \gets \emptyset$
\Function{bron\_kerbosch}{$candidates,not$}
	\If{$candidates = \emptyset$ \textbf{and} $not = \emptyset$}
		\If{$size(biggest\_clique) < size(compsub)$}
		 	\State $biggest\_clique \gets compsub$\Comment Największa klika
		 \EndIf
	\Else
	\State $pivot \gets vertex\_with\_maxdeg(candidates \cup not)$
	\State $candidates\_to\_check \gets candidates \setminus neighbors(pivot)$
	\For{\textbf{each} $v$ in $candidates\_to\_check$}
		\State $compsub \gets compsub \cup \{v\}$
		\State $candidates \gets candidates \setminus \{v\}$
		\State $new\_candidates \gets candidates \cap neighbors(v)$
		\State $new\_not \gets not \cap neighbors(v)$
		\State\Call{bron\_kerbosch}{$new\_candidates, new\_not$}
		\State $compsub \gets compsub \setminus \{v\}$
		\State $not \gets not \cup \{v\}$
	\EndFor
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage
\subsection{Opis działania}
Istotą działania przedstawionego algorytmu jest utrzymywanie trzech rozłącznych zbiorów: $compsub$, $candidates$ oraz $not$.

Algorytm Brona--Kerboscha znajduje maksymalne kliki składające się ze wszystkich wierzchołków należących do zbioru $compsub$, niektórych należących do zbioru $candidates$, i z żadnego, który należy do zbioru $not$.

Poniżej przedstawiona została charakterystyka każdego ze zbiorów wykorzystywanych przez algorytm:
\begin{itemize}
	\item $compsub$ 
	
	do zbioru należą wszystkie wierzchołki grafu, które tworzą powstającą klikę.
	\item $candidates$
	
	do zbioru należą wierzchołki grafu, które mogą posłużyć do rozszerzenia zbioru $compsub$.
	\item $not$ 
	
	do zbioru należą te wierzchołki, które były już wcześniej wykorzystane do rozszerzenia zbioru $compsub$.
\end{itemize}

Należy zauważyć, iż wszystkie wierzchołki, które są połączone z każdym wierzchołkiem należącym do zbioru $compsub$ znajdują się albo w zbiorze $candidates$ albo $not$.

\bigskip
Zmodyfikowana wersja algorytmu Brona--Kerboscha wprowadza pojęcie wierzchołka zwrotnego (dalej oznaczanego $pivot$), który wybierany jest ze zbioru $candidates \cup not$ jako wierzchołek o największym stopniu.

\bigskip
W każdym rekurencyjnym wywołaniu algorytmu rozważane są wierzchołki należące do zbioru $candidates$. Jeśli zbiory $candidates$ i $not$ są puste, sprawdzane jest czy znaleziona maksymalna klika (oparta na wierzchołkach ze zbioru $compsub$) jest większa od największej dotychczas znalezionej kliki. Jeśli tak, to znaleziona klika staje się największą, w przeciwnym wypadku największa klika pozostawiana jest bez zmian.

W przypadku, gdy zbiory $candidates$ i $not$ nie są puste, dla każdego wierzchołka ze zbioru $candidates \setminus neighbors(pivot)$ następuje rekurencyjne wywołanie algorytmu, w którym bieżący wierzchołek $v$ dodawany jest do zbioru $compsub$ i usuwany ze zbioru $candidates$, a w zbiorach $candidates$ i $not$ pozostawiane są tylko te wierzchołki grafu, które są sąsiadami wierzchołka $v$. Następnie, wierzchołek $v$ jest dodawany do zbioru $not$ jako już wykorzystany do rozszerzenia kliki oraz usuwany ze zbioru $compsub$.

Wynikiem działania algorytmu jest zbiór $biggest\_clique$, który początkowo inicjowany jest jako zbiór pusty. W przypadku, gdy znaleziona zostanie największa klika, zbiór ten zawiera wierzchołki ją tworzące.

\section{Struktury danych}
\section{Testy}
\subsection{Badanie poprawności zwracanych wyników}
\subsection{Badanie czasu wykonania dla różnych typów grafów}

\bibliographystyle{plain}
\bibliography{references}
\end{document}